using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace EasyCrypto
{
    /// <summary>
    /// AES encryption helper class
    /// </summary>
    public static class AesEncryption
    {
        private static readonly byte[] _emptyKey = new byte[32];

        // TODO: consider moving regions in separate classes
        
        #region methods with password

        /// <summary>
        /// Encrypts string and returns string. Salt and IV will be embedded to encrypted string.
        /// Can later be decrypted with <see cref="DecryptWithPassword(string, string)"/>
        /// IV and salt are generated by <see cref="CryptoRandom"/> which is using System.Security.Cryptography.Rfc2898DeriveBytes.
        /// IV size is 16 bytes (128 bits) and key size will be 32 bytes (256 bits).
        /// </summary>
        /// <param name="dataToEncrypt">String to encrypt</param>
        /// <param name="password">Password that is used for generating key for encryption/decryption</param>
        /// <returns>Encrypted string</returns>
        public static string EncryptWithPassword(string dataToEncrypt, string password)
        {
            byte[] data = Encoding.UTF8.GetBytes(dataToEncrypt);
            byte[] result = EncryptWithPassword(data, password);
            return Convert.ToBase64String(result);
        }

        /// <summary>
        /// Decrypts string with embedded salt and IV that are encrypted with <see cref="EncryptWithPassword(string, string)"/>
        /// </summary>
        /// <param name="dataToDecrypt">string to decrypt</param>
        /// <param name="password">Password that is used for generating key for encryption/decryption</param>
        /// <returns>Decrypted string</returns>
        public static string DecryptWithPassword(string dataToDecrypt, string password)
        {
            byte[] data = Convert.FromBase64String(dataToDecrypt);
            byte[] result = DecryptWithPassword(data, password);
            return Encoding.UTF8.GetString(result);
        }

        /// <summary>
        /// Encrypts byte array and returns byte array. Salt and IV will be embedded in result.
        /// Can be later decrypted using <see cref="DecryptWithPassword(byte[], string)"/>
        /// IV and salt are generated by <see cref="CryptoRandom"/> which is using System.Security.Cryptography.Rfc2898DeriveBytes.
        /// IV size is 16 bytes (128 bits) and key size will be 32 bytes (256 bits).
        /// </summary>
        /// <param name="dataToEncrypt">Bytes to encrypt</param>
        /// <param name="password">Password that is used for generating key for encryption/decryption</param>
        /// <returns>Encrypted bytes</returns>
        public static byte[] EncryptWithPassword(byte[] dataToEncrypt, string password)
            => HandleByteToStream(dataToEncrypt, (inStream, outStream) => EncryptWithPassword(inStream, password, outStream));

        /// <summary>
        /// Decrypts byte array with embedded salt and IV that is encrypted with <see cref="EncryptWithPassword(byte[], string)"/>
        /// </summary>
        /// <param name="dataToDecrypt"></param>
        /// <param name="password">Password that is used for generating key for encryption/decryption</param>
        /// <returns>Decrypted bytes</returns>
        public static byte[] DecryptWithPassword(byte[] dataToDecrypt, string password)
            => HandleByteToStream(dataToDecrypt, (inStream, outStream) => DecryptWithPassword(inStream, password, outStream));

        /// <summary>
        /// Reads data from stream (parameter dataToEncrypt) and writes encrypted data to stream (parameter destination).
        /// Can be later decrypted using <see cref="DecryptWithPassword(Stream, string, Stream)"/>.
        /// Salt and IV will be embedded to resulting stream.
        /// IV and salt are generated by <see cref="CryptoRandom"/> which is using System.Security.Cryptography.Rfc2898DeriveBytes.
        /// IV size is 16 bytes (128 bits) and key size will be 32 bytes (256 bits).
        /// </summary>
        /// <param name="dataToEncrypt">Stream containing data to encrypt</param>
        /// <param name="password">Password that is used for generating key for encryption/decryption</param>
        /// <param name="destination">Stream to which to write encrypted data</param>
        public static void EncryptWithPassword(Stream dataToEncrypt, string password, Stream destination)
        {
            byte[] salt;
            var ph = new PasswordHasher(32);
            byte[] key = ph.HashPasswordAndGenerateSalt(password, out salt);
            EncryptAndEmbedIv(dataToEncrypt, key, destination, salt);
        }

        /// <summary>
        /// Reads data from stream (parameter dataToEncrypt) and writes decrypted data to stream (parameter destination).
        /// Result can be lated decrypted with <see cref="DecryptWithPassword(Stream, string, Stream)"/>
        /// IV and salt will are read from input data (parameter dataToDecrypt).
        /// </summary>
        /// <param name="dataToDecrypt">Stream containing data to decrypt</param>
        /// <param name="password">Password that is used for generating key for encryption/decryption</param>
        /// <param name="destination">Stream to which to write decrypted data</param>
        public static void DecryptWithPassword(Stream dataToDecrypt, string password, Stream destination)
            => DecryptWithEmbeddedIv(dataToDecrypt, null, destination, password);

        #endregion

        #region methods with embedded iv

        /// <summary>
        /// Encrypts bytes and embeds IV. Can be decrypted with <see cref="DecryptWithEmbeddedIv(byte[], byte[])"/>
        /// IV is generated by <see cref="CryptoRandom"/> which is using System.Security.Cryptography.Rfc2898DeriveBytes.
        /// IV size is 16 bytes (128 bits) and key size will be 32 bytes (256 bits).
        /// </summary>
        /// <param name="dataToEncrypt">Bytes to encrypt</param>
        /// <param name="key">Key that will be used for encryption/decryption</param>
        /// <returns>Byte array, encrypted data with embedded IV</returns>
        public static byte[] EncryptAndEmbedIv(byte[] dataToEncrypt, byte[] key) 
            => HandleByteToStream(dataToEncrypt, (inStream, outStream) => EncryptAndEmbedIv(inStream, key, outStream));

        /// <summary>
        /// Decrypts bytes with embedded IV encrypted with <see cref="EncryptAndEmbedIv(byte[], byte[])"/>
        /// </summary>
        /// <param name="dataToDecrypt">Bytes, data with embedded IV, to decrypt</param>
        /// <param name="key">Key that will be used for encryption/decryption, must be 16, 24 or 32 bytes long.</param>
        /// <returns>Byte array, encrypted data</returns>
        public static byte[] DecryptWithEmbeddedIv(byte[] dataToDecrypt, byte[] key) 
            => HandleByteToStream(dataToDecrypt, (inStream, outStream) => DecryptWithEmbeddedIv(inStream, key, outStream));

        /// <summary>
        /// Encrypts and embeds IV into result. Data is read from stream and encrypted data is wrote to stream.
        /// Can be decrypted with <see cref="DecryptWithEmbeddedIv(Stream, byte[], Stream)"/>
        /// IV is generated by <see cref="CryptoRandom"/> which is using System.Security.Cryptography.Rfc2898DeriveBytes.
        /// IV size is 16 bytes (128 bits).
        /// </summary>
        /// <param name="dataToEncrypt">Stream containing data to encrypt</param>
        /// <param name="key">Key that will be used for encryption/decryption, must be 16, 24 or 32 bytes long.</param>
        /// <param name="destination"></param>
        public static void EncryptAndEmbedIv(Stream dataToEncrypt, byte[] key, Stream destination)
            => EncryptAndEmbedIv(dataToEncrypt, key, destination, null);

        private static void EncryptAndEmbedIv(Stream dataToEncrypt, byte[] key, Stream destination, byte[] salt)
        {
            byte[] iv = CryptoRandom.NextBytesStatic(16);
            Encrypt(new CryptoRequest
            {
                EmbedIV = true,
                InData = dataToEncrypt,
                OutData = destination,
                IV = iv,
                Key = key,
                EmbedSalt = salt != null,
                Salt = salt
            });
        }

        /// <summary>
        /// Decrypts data with embedded IV, that is encrypted with <see cref="EncryptAndEmbedIv(Stream, byte[], Stream)"/>, into result. 
        /// Data is read from stream and decrypted data is wrote to stream.
        /// </summary>
        /// <param name="dataToDecrypt">Stream containing data to decrypt.</param>
        /// <param name="key">Key that will be used for encryption/decryption, must be 16, 24 or 32 bytes long.</param>
        /// <param name="destination">Stream to which decrypted data will be wrote.</param>
        public static void DecryptWithEmbeddedIv(Stream dataToDecrypt, byte[] key, Stream destination)
            => DecryptWithEmbeddedIv(dataToDecrypt, key, destination, null);

        private static void DecryptWithEmbeddedIv(Stream dataToDecrypt, byte[] key, Stream destination, string password)
        {
            Decrypt(new CryptoRequest
            {
                EmbedIV = true,
                InData = dataToDecrypt,
                OutData = destination,
                Key = key,
                Password = password,
                EmbedSalt = password != null
            });
        }

        #endregion

        #region base methods

        /// <summary>
        /// Encrypts data from byte array to byte array.
        /// </summary>
        /// <param name="dataToEncrypt"></param>
        /// <param name="key">Key that will be used for encryption/decryption, must be 16, 24 or 32 bytes long.</param>
        /// <param name="iv">Initialization vector, must be 16 bytes</param>
        /// <returns></returns>
        public static byte[] Encrypt(byte[] dataToEncrypt, byte[] key, byte[] iv)
            => HandleByteToStream(dataToEncrypt, (inStream, outStream) =>
            Encrypt(new CryptoRequest
            {
                EmbedIV = true,
                InData = inStream,
                OutData = outStream,
                IV = iv,
                Key = key
            }));

        /// <summary>
        /// Decrypts data from byte array to byte array.
        /// </summary>
        /// <param name="dataToDecrypt"></param>
        /// <param name="key">Key that will be used for encryption/decryption, must be 16, 24 or 32 bytes long.</param>
        /// <param name="iv">Initialization vector, must be 16 bytes</param>
        /// <returns></returns>
        public static byte[] Decrypt(byte[] dataToDecrypt, byte[] key, byte[] iv) 
            => HandleByteToStream(dataToDecrypt, (inStream, outStream) => Decrypt(inStream, key, iv, outStream));

        /// <summary>
        /// Encrypts data from stream to stream.
        /// </summary>
        /// <param name="dataToEncrypt">Stream with data to decrypt.</param>
        /// <param name="key">Key that will be used for encryption/decryption, must be 16, 24 or 32 bytes long.</param>
        /// <param name="iv">Initialization vector, must be 16 bytes</param>
        /// <param name="destination">Stream to which encrypted data will be wrote.</param>
        public static void Encrypt(Stream dataToEncrypt, byte[] key, byte[] iv, Stream destination)
            => Encrypt(new CryptoRequest
            {
                SkipValidations = false,
                InData = dataToEncrypt,
                OutData = destination,
                Key = key,
                IV = iv
            });

        /// <summary>
        /// Decrypts data from stream to stream.
        /// </summary>
        /// <param name="dataToDecrypt">Stream with data to encrypt.</param>
        /// <param name="key">Key that will be used for encryption/decryption, must be 16, 24 or 32 bytes long.</param>
        /// <param name="iv">Initialization vector, must be 16 bytes</param>
        /// <param name="destination">Stream to which decrypted data will be wrote.</param>
        public static void Decrypt(Stream dataToDecrypt, byte[] key, byte[] iv, Stream destination)
            => Decrypt(new CryptoRequest
            {
                IV = iv,
                Key = key,
                InData = dataToDecrypt,
                OutData = destination,
                SkipValidations = false
            });

        internal static void Encrypt(CryptoRequest request)
        {
            if (request.Key.Length != 32) throw new ArgumentException("Key must be 32 bytes long.");
            if (request.IV == null || request.IV.Length != 16) throw new ArgumentException("IV must be 16 bytes in length");

            CryptoContainer container = null;
            if (!request.SkipValidations)
            {
                container = CryptoContainer.CreateForEncryption(request);
                container.WriteEmptyHeaderData();
            }

            using (var aes = new AesManaged())
            {
                aes.IV = request.IV;
                aes.Key = request.Key;
                aes.Padding = PaddingMode.ISO10126;
                aes.BlockSize = 128;
                if (request.SkipValidations)
                {
                    aes.Padding = PaddingMode.Zeros;
                }
                using (var encryptor = aes.CreateEncryptor())
                {
                    CryptoStream cs = new CryptoStream(request.OutData, encryptor, CryptoStreamMode.Write);
                    int bufferSize = aes.BlockSize;
                    byte[] buffer = new byte[bufferSize];
                    int read = 0;
                    while ((read = request.InData.Read(buffer, 0, bufferSize)) > 0)
                    {
                        cs.Write(buffer, 0, read);
                        cs.Flush();
                    }
                    cs.FlushFinalBlock();
                }
            }
            if (!request.SkipValidations)
            {
                container.WriteChecksAndEmbeddedData();
            }
        }

        internal static void Decrypt(CryptoRequest request)
        {
            CryptoContainer container = null;
            if (!request.SkipValidations)
            {
                container = CryptoContainer.CreateForDecryption(request);
                var validationResult = container.ReadAndValidateDataForDecryption();
                if (!validationResult.IsValid)
                {
                    throw validationResult.ExceptionToThrow ?? new Exception("Unknown error");
                }
                request.IV = container.GetIV();
                if (request.Password != null)
                {
                    request.Key = container.CalculateKey();
                }
            }

            if (request.Key == null || request.Key.Length != 32) throw new ArgumentException("Key must be 32 bytes long.");
            if (request.IV == null || request.IV.Length != 16) throw new ArgumentException($"IV must be 16 bytes in length");

            using (var aes = new AesManaged())
            {
                aes.IV = request.IV;
                aes.Key = request.Key;
                aes.Padding = PaddingMode.ISO10126;
                if (request.SkipValidations)
                {
                    aes.Padding = PaddingMode.Zeros;
                }
                aes.BlockSize = 128;
                if (request.SkipValidations)
                {
                    aes.Padding = PaddingMode.Zeros;
                }
                using (var decryptor = aes.CreateDecryptor())
                {
                    CryptoStream cs = new CryptoStream(request.OutData, decryptor, CryptoStreamMode.Write);
                    int bufferSize = aes.BlockSize;
                    byte[] buffer = new byte[bufferSize];
                    int read = 0;
                    while ((read = request.InData.Read(buffer, 0, bufferSize)) > 0)
                    {
                        cs.Write(buffer, 0, read);
                        cs.Flush();
                    }
                    cs.FlushFinalBlock();
                }
            }
        }

        #endregion

        #region validations
        
        public static ValidationResult ValidateEncryptedData(byte[] encryptedData, byte[] key, byte[] iv)
            => HandleByteToStream(encryptedData, (stream) => ValidateEncryptedData(stream, key, iv));

        public static ValidationResult ValidateEncryptedData(Stream encryptedData, byte[] key, byte[] iv)
            => ValidateEncryptedData(new CryptoRequest
            {
                InData = encryptedData,
                IV = iv,
                Key = key
            });

        public static ValidationResult ValidateEncryptedDataWithEmbededIv(byte[] encryptedData, byte[] key)
            => HandleByteToStream(encryptedData, (stream) => ValidateEncryptedDataWithEmbededIv(stream, key));
            
        public static ValidationResult ValidateEncryptedDataWithEmbededIv(Stream encryptedData, byte[] key)
            => ValidateEncryptedData(new CryptoRequest
            {
                InData = encryptedData,
                Key = key,
                EmbedIV = true
            });

        public static ValidationResult ValidateEncryptedDataWithPassword(string encryptedData, string password)
            => ValidateEncryptedDataWithPassword(Convert.FromBase64String(encryptedData), password);

        public static ValidationResult ValidateEncryptedDataWithPassword(byte[] encryptedData, string password)
            => HandleByteToStream(encryptedData, (stream) => ValidateEncryptedDataWithPassword(stream, password));

        public static ValidationResult ValidateEncryptedDataWithPassword(Stream encryptedData, string password)
            => ValidateEncryptedData(new CryptoRequest
            {
                InData = encryptedData,
                EmbedIV = true,
                EmbedSalt = true,
                Password = password
            });

        internal static ValidationResult ValidateEncryptedData(CryptoRequest request)
            => CryptoContainer.CreateForDecryption(request).ReadAndValidateDataForDecryption();

        #endregion

        internal static byte[] HandleByteToStream(byte[] data, Action<Stream, Stream> action)
        {
            byte[] result;
            using (Stream inStream = new MemoryStream())
            using (Stream outStream = new MemoryStream())
            {
                inStream.Write(data, 0, data.Length);
                inStream.Flush();
                inStream.Position = 0;
                action(inStream, outStream);
                outStream.Position = 0;
                result = new byte[outStream.Length];
                outStream.Read(result, 0, result.Length);
            }
            return result;
        }

        internal static ValidationResult HandleByteToStream(byte[] data, Func<Stream, ValidationResult> func)
        {
            ValidationResult result;
            using (Stream stream = new MemoryStream())
            {
                stream.Write(data, 0, data.Length);
                stream.Flush();
                stream.Position = 0;
                result = func(stream);
            }
            return result;
        }
    }
}
